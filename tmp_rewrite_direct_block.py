from pathlib import Path

TARGET = Path("examples/diagnostic_sav_vs_mmsmp_20190127.py")

text = TARGET.read_text(encoding="utf-8")
lines = text.splitlines()

# Keep everything up through the BN overlay (line 256 in the current file)
prefix = lines[:256]
# Keep everything starting at the existing VN block (line 366 in the current file)
suffix = lines[365:]

direct_block = [
    "    # Direct BL/BM/BN comparison (active): .sav B_LMN vs B_gsm rotated by .sav LMN",
    "    # This block uses the verified native ordering of the .sav B_LMN arrays,",
    "    # which store components as (B_N, B_M, B_L) in columns (0, 1, 2).",
    "    if key in B_LMN:",
    "        b_entry = B_LMN[key]",
    "        t_raw = np.asarray(b_entry.get('t', []), float)",
    "        blmn = np.asarray(b_entry.get('blmn', []), float)",
    "        if t_raw.size and blmn.size:",
    "            idx_sav = pd.to_datetime(t_raw, unit='s', utc=True)",
    "",
    "            def _extract_component(arr: np.ndarray, idx: int) -> np.ndarray:",
    "                \"\"\"Extract a single component from possible (N,3), (3,N), or flat layouts.\"\"\"",
    "                if arr.ndim == 2 and arr.shape[1] >= 3:",
    "                    return arr[:, idx]",
    "                if arr.ndim == 2 and arr.shape[0] == 3:",
    "                    return arr[idx, :]",
    "                flat = arr.reshape(-1)",
    "                start = idx",
    "                step = 3",
    "                return flat[start::step] if flat.size >= (idx + 1) else flat",
    "",
    "            # Common 1 s grid over the event TRANGE",
    "            t0_evt = pd.to_datetime(TRANGE[0], utc=True)",
    "            t1_evt = pd.to_datetime(TRANGE[1], utc=True)",
    "            grid_evt = pd.date_range(t0_evt, t1_evt, freq='1s')",
    "",
    "            # CDF-rotated B components in .sav LMN on the same grid",
    "            B_cdf_grid = {",
    "                'L': BL_sav.resample('1s').mean().reindex(grid_evt)",
    "                'M': BM_sav.resample('1s').mean().reindex(grid_evt)",
    "                'N': BN_sav.resample('1s').mean().reindex(grid_evt)",
    "            }",
    "",
    "            # Map desired (L, M, N) onto the native (B_N, B_M, B_L) column ordering",
    "            # in .sav B_LMN",
    "            for comp_name, idx_comp, ylabel, dlabel in [",
    "                ('L', 2, 'B_L (nT)', '\u0394B_L (nT)'),  # raw col 2 is B_L",
    "                ('M', 1, 'B_M (nT)', '\u0394B_M (nT)'),  # raw col 1 is B_M",
    "                ('N', 0, 'B_N (nT)', '\u0394B_N (nT)'),  # raw col 0 is B_N",
    "            ]:",
    "                vals_sav = _extract_component(blmn, idx_comp)",
    "                if vals_sav.size == 0:",
    "                    continue",
    "                B_sav_direct_raw = pd.Series(",
    "                    vals_sav, index=idx_sav, name=f'B{comp_name}_sav_direct'",
    "                )",
    "",
    "                B_cdf_1s = B_cdf_grid[comp_name]",
    "                B_sav_1s = B_sav_direct_raw.resample('1s').mean().reindex(grid_evt)",
    "",
    "                mae_bd, rmse_bd, corr_bd, max_bd, n_valid_bd, n_gaps_bd, cov_bd = _stats_with_gaps(",
    "                    grid_evt, B_cdf_1s, B_sav_1s",
    "                )",
    "",
    "                # Store consolidated stats for direct B component comparison",
    "                all_stats.append({",
    "                    'probe': key,",
    "                    'quantity': f'B{comp_name}_direct',",
    "                    'mae': float(mae_bd),",
    "                    'rmse': float(rmse_bd),",
    "                    'correlation': float(corr_bd),",
    "                    'max_abs_diff': float(max_bd),",
    "                    'n_samples': int(n_valid_bd),",
    "                    'n_gaps': int(n_gaps_bd),",
    "                    'coverage_fraction': float(cov_bd),",
    "                })",
    "",
    "                # Two-panel figure: overlay + difference (\u0394B = CDF_rotated \u2212 .sav B_LMN)",
    "                fig2, (ax_top, ax_bot) = plt.subplots(2, 1, figsize=(10, 6), sharex=True)",
    "",
    "                ax_top.plot(",
    "                    grid_evt,",
    "                    B_cdf_1s,",
    "                    label=f'B_{comp_name} (CDF rotated by .sav LMN)',",
    "                    lw=1.0,",
    "                )",
    "                ax_top.plot(",
    "                    grid_evt,",
    "                    B_sav_1s,",
    "                    label=f'B_{comp_name} (.sav B_LMN direct)',",
    "                    lw=1.0,",
    "                    alpha=0.85,",
    "                )",
    "                ax_top.set_ylabel(ylabel)",
    "                ax_top.set_title(",
    "                    f'MMS{key} Direct B_{comp_name} comparison (.sav B_LMN vs CDF)'",
    "                )",
    "                ax_top.grid(True, alpha=0.3)",
    "                ax_top.legend()",
    "",
    "                diff_dir = B_cdf_1s - B_sav_1s",
    "                ax_bot.plot(grid_evt, diff_dir, lw=1.0, color='C2')",
    "                ax_bot.axhline(0.0, color='k', ls='--', lw=0.8)",
    "                ax_bot.axhline(0.5, color='r', ls=':', lw=0.8, alpha=0.7)",
    "                ax_bot.axhline(-0.5, color='r', ls=':', lw=0.8, alpha=0.7)",
    "                ax_bot.set_ylabel(dlabel)",
    "                ax_bot.set_xlabel('Time (UTC)')",
    "                ax_bot.grid(True, alpha=0.3)",
    "",
    "                fig2.tight_layout()",
    "                fig2.savefig(OUT / f'comparison_b{comp_name.lower()}_direct_mms{key}.png', dpi=220)",
    "                plt.close(fig2)",
]

new_lines = prefix + direct_block + suffix

TARGET.write_text("\n".join(new_lines) + "\n", encoding="utf-8")
print("Rewrote direct B_LMN comparison block in", TARGET)

